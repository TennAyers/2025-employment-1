@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration
@{
    ViewData["Title"] = "AR Dashboard System";
    var geminiKey = Configuration["GeminiSettings:ApiKey"];
}

<style>
    /* --- 全画面設定と黒背景 --- */
    /* このページだけヘッダー・フッターを隠して没入感を出す */
    header, footer, .navbar { display: none !important; }
    
    body, html { 
        margin: 0; padding: 0; width: 100%; height: 100%; 
        overflow: hidden; background-color: #050505; 
    }
    
    /* Layout.cshtmlのコンテナ制限を解除 */
    main.pb-3 { padding-bottom: 0 !important; }
    .container { max-width: none !important; padding: 0 !important; margin: 0 !important; }

    /* メインコンテナ */
    .dashboard-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
    }

    /* 1. ビデオ（一番奥） */
    #video {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: auto;
        height: auto;
        z-index: 1;
    }

    /* 2. キャンバス（ビデオの上） */
    #overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 2;
        pointer-events: none;
    }

    /* 3. 操作パネル（最前面） */
    .panel-left, .panel-right {
        z-index: 100;
        pointer-events: auto; /* パネル内のクリックは有効 */
    }

    /* --- チャット機能のスタイル --- */
    /* フローティングボタン */
    #chatFloatBtn {
        position: absolute; bottom: 20px; right: 20px;
        width: 60px; height: 60px;
        border-radius: 50%;
        background: rgba(0, 212, 255, 0.2);
        border: 2px solid #00d4ff;
        color: #00d4ff;
        font-size: 24px;
        display: flex; justify-content: center; align-items: center;
        cursor: pointer;
        z-index: 200;
        transition: all 0.3s;
        box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
    }
    #chatFloatBtn:hover { background: rgba(0, 212, 255, 0.5); transform: scale(1.1); }
    
    /* 通知バッジ */
    #chatBadge {
        position: absolute; top: 0; right: 0;
        width: 15px; height: 15px;
        background: #ff0055;
        border-radius: 50%;
        display: none; /* 初期は非表示 */
        box-shadow: 0 0 5px #ff0055;
    }

    /* AR風モーダル */
    .ar-modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        display: none; /* 初期は非表示 */
        justify-content: center; align-items: center;
    }
    .ar-modal-content {
        width: 90%; max-width: 500px;
        background: rgba(10, 20, 30, 0.95);
        border: 1px solid #00d4ff;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        position: relative;
        color: white;
    }
    .close-modal {
        position: absolute; top: 10px; right: 15px;
        color: #aaa; cursor: pointer; font-size: 1.5rem;
        z-index: 1001;
    }
    .close-modal:hover { color: white; }
</style>

<div class="dashboard-container">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay" style="pointer-events: none;"></canvas>

    <!-- 左パネル -->
    <div class="panel-left">
        <h3>新規登録</h3>
        
        <div class="input-group">
            <input type="text" id="regName" class="ar-input" placeholder="名前">
            <button class="mic-btn" type="button" onclick="window.startSpeech('regName', this)">🎤</button>
        </div>
        
        <div class="input-group">
            <input type="text" id="regAffiliation" class="ar-input" placeholder="所属">
            <button class="mic-btn" type="button" onclick="window.startSpeech('regAffiliation', this)">🎤</button>
        </div>
        
        <div class="input-group">
            <textarea id="regNotes" class="ar-input" placeholder="メモ" rows="3"></textarea>
            <button class="mic-btn" type="button" onclick="window.startSpeech('regNotes', this)">🎤</button>
        </div>

        <button id="registerButton" class="ar-btn">顔データを登録</button>
        <div id="status" class="status-bar">システム準備完了</div>

        <div style="margin-top: 20px; text-align: center;">
            <a href="/Home/Edit" style="color: #00d4ff; text-decoration: none; font-size: 0.8rem;">
                情報編集画面&gt;
            </a>
            <br>
            <a href="/" style="color: #888; text-decoration: none; font-size: 0.7rem;">
                HOMEへ戻る (ヘッダー表示)
            </a>
        </div>
    </div>

    <!-- 右パネル -->
    <div class="panel-right">
        <h3>対象分析</h3>
        
        <div class="info-card">
            <div style="font-size:0.7rem; color:#aaa;">名前</div>
            <div id="detName" style="font-size:1.2rem; font-weight:bold;">スキャン中...</div>
        </div>

        <div class="info-card">
            <div style="font-size:0.7rem; color:#aaa;">所属</div>
            <div id="detAffiliation" style="font-size:1rem;">---</div>
        </div>
        
        <div style="margin-top:15px; border-bottom:1px solid #00ff88; color:#00ff88;">会話ログ</div>
        <div id="logContainer" class="log-container">
            <div style="text-align:center; color:#666; margin-top:20px;">履歴なし</div>
        </div>

        <div id="logInputArea" style="opacity:0.5; pointer-events:none; margin-top:auto;">
            <div class="input-group" style="margin-bottom:5px;">
                <input type="text" id="newLogContent" class="ar-input" placeholder="会話内容...">
                <button class="mic-btn" type="button" onclick="window.startSpeech('newLogContent', this)">🎤</button>
            </div>
            <button id="addLogButton" class="ar-btn" style="padding:10px; font-size:0.8rem;">記録を追加</button>
        </div>
    </div>

    <!-- ★チャットフローティングボタン -->
    <div id="chatFloatBtn" onclick="toggleChatModal()">
        💬
        <div id="chatBadge"></div>
    </div>

    <!-- ★チャットモーダル -->
    <div id="chatModal" class="ar-modal-overlay">
        <div class="ar-modal-content">
            <span class="close-modal" onclick="toggleChatModal()">×</span>
            <!-- Ajaxで読み込まれるコンテンツエリア -->
            <div id="chatContentContainer">
                <div class="text-center text-white p-5">読み込み中...</div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <!-- 必要なライブラリの読み込み -->
    <script src="https://cdn.jsdelivr.net/npm/@@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="~/js/face-api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.js"></script>

    <script>
        // =======================================================
        // 0. グローバル変数・設定
        // =======================================================
        const GEMINI_API_KEY = "@geminiKey";

        // DOM要素
        const video = document.getElementById('video');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const detNameEl = document.getElementById('detName');
        const detAffiliationEl = document.getElementById('detAffiliation');
        const logContainer = document.getElementById('logContainer');
        const logInputArea = document.getElementById('logInputArea');
        const newLogInput = document.getElementById('newLogContent');

        // 指カーソル専用キャンバス（最前面）作成
        const cursorCanvas = document.createElement('canvas');
        const cursorCtx = cursorCanvas.getContext('2d');
        cursorCanvas.id = 'cursor-layer';
        Object.assign(cursorCanvas.style, {
            position: 'absolute', top: '50%', left: '50%',
            transform: 'translate(-50%, -50%)', pointerEvents: 'none', zIndex: '1000'
        });
        document.querySelector('.dashboard-container').appendChild(cursorCanvas);

        // 状態管理変数
        let displaySize = { width: 640, height: 480 };
        let lastDetectedDescriptor = null;
        let currentIdentifiedUserId = null;
        let hands = null;
        let lastHandLandmarks = null;
        let activeRecognition = null;

        // パフォーマンス調整用
        let frameCount = 0;
        let lastDetections = [];
        let isProcessingFace = false;

        // 指カーソル用
        let cursorX = 0, cursorY = 0;
        const SMOOTHING_FACTOR = 0.8;
        let isPinching = false, wasPinching = false;

        // ジェスチャー（チェックマーク）用変数
        let gestureCooldown = false;
        let lastFocusedInputId = 'newLogContent'; // デフォルトの入力先

        // =======================================================
        // 1. チャット機能 & SignalR (ここが新しい部分)
        // =======================================================
        let chatConnection = null;
        let activeRoomId = null;

        // SignalR接続開始
        function initSignalR() {
            chatConnection = new signalR.HubConnectionBuilder()
                .withUrl("/chathub")
                .build();

            chatConnection.on("ReceiveMessage", function (user, message, time) {
                // チャットルームが開いている場合、画面に追記
                const chatContainer = document.getElementById("chatMessages");
                if (chatContainer) {
                    const myName = document.getElementById("currentUserName")?.value;
                    const isMe = user === myName;
                    
                    const align = isMe ? "justify-content-end" : "justify-content-start";
                    const bg = isMe ? "bg-primary text-white" : "bg-secondary text-light";
                    const senderHtml = !isMe ? `<small class="d-block text-warning" style="font-size: 0.7em;">${user}</small>` : "";

                    const html = `
                        <div class="d-flex ${align} mb-2">
                            <div class="p-2 rounded ${bg}" style="max-width: 80%; font-size: 0.9rem;">
                                ${senderHtml}
                                <span>${message}</span>
                                <div style="font-size: 0.6em; text-align: right; opacity: 0.7;">${time}</div>
                            </div>
                        </div>`;
                    
                    chatContainer.insertAdjacentHTML('beforeend', html);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                } else {
                    // 閉じていたら通知バッジを表示
                    const badge = document.getElementById("chatBadge");
                    if (badge) badge.style.display = "block";
                }
            });

            chatConnection.start().catch(err => console.error("SignalR Connection Error: ", err));
        }

        // モーダル制御
        function toggleChatModal() {
            const modal = document.getElementById("chatModal");
            const isHidden = modal.style.display === "none" || modal.style.display === "";
            
            if (isHidden) {
                modal.style.display = "flex";
                loadChatList(); // 開いた時に一覧をロード
                document.getElementById("chatBadge").style.display = "none"; // 通知を消す
            } else {
                modal.style.display = "none";
                activeRoomId = null;
            }
        }

        // Ajax: 一覧読み込み
        function loadChatList() {
            activeRoomId = null;
            fetch('/Chat/GetListPartial')
                .then(res => res.text())
                .then(html => {
                    document.getElementById("chatContentContainer").innerHTML = html;
                })
                .catch(err => {
                    document.getElementById("chatContentContainer").innerHTML = '<p class="text-danger">読み込みエラー</p>';
                });
        }

        // Ajax: ルーム読み込み
        function openChatRoom(roomId) {
            fetch(`/Chat/GetRoomPartial?id=${roomId}`)
                .then(res => res.text())
                .then(html => {
                    document.getElementById("chatContentContainer").innerHTML = html;
                    activeRoomId = roomId;
                    
                    // SignalRグループに参加
                    if (chatConnection) {
                        chatConnection.invoke("JoinRoom", roomId.toString()).catch(err => console.error(err));
                    }

                    // 最下部へスクロール
                    const msgArea = document.getElementById("chatMessages");
                    if(msgArea) msgArea.scrollTop = msgArea.scrollHeight;
                });
        }

        // Ajax: メッセージ送信
        function sendChatMessage(roomId) {
            const input = document.getElementById("chatInput");
            const message = input.value;
            if (!message) return;

            const myName = document.getElementById("currentUserName").value;

            // DB保存
            fetch('/Chat/SaveMessage', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `roomId=${roomId}&content=${encodeURIComponent(message)}`
            }).then(() => {
                // SignalR配信
                chatConnection.invoke("SendMessage", roomId.toString(), myName, message);
                input.value = "";
            });
        }

        function handleChatEnter(e) {
            if (e.key === 'Enter') {
                const id = document.getElementById("currentRoomId").value;
                sendChatMessage(id);
            }
        }

        // Ajax: 新規ルーム作成モード切替
        function toggleCreateMode() {
            const list = document.getElementById("roomListArea");
            const create = document.getElementById("createRoomArea");
            if (list.style.display === "none") {
                list.style.display = "block";
                create.style.display = "none";
            } else {
                list.style.display = "none";
                create.style.display = "block";
            }
        }

        // Ajax: ルーム作成実行
        function submitCreateRoom() {
            const name = document.getElementById("newRoomName").value;
            if (!name) { alert("ルーム名を入力してください"); return; }

            const checkboxes = document.querySelectorAll('input[name="targetUserIds"]:checked');
            const userIds = Array.from(checkboxes).map(c => c.value);

            const formData = new URLSearchParams();
            formData.append('roomName', name);
            userIds.forEach(id => formData.append('targetUserIds', id));

            fetch('/Chat/CreateRoomAjax', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: formData
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    openChatRoom(data.roomId); // 作成したらそのまま入室
                } else {
                    alert("作成失敗");
                }
            });
        }

        // =======================================================
        // 2. フォーカス追跡 & 音声入力 (既存機能)
        // =======================================================
        
        window.addEventListener('load', () => {
            const inputs = document.querySelectorAll('input[type="text"], textarea');
            inputs.forEach(input => {
                input.addEventListener('focus', () => lastFocusedInputId = input.id);
                input.addEventListener('click', () => lastFocusedInputId = input.id);
            });
            // SignalR初期化
            initSignalR();
        });

        window.startSpeech = function(targetId, btn) {
            lastFocusedInputId = targetId;
            if (!('webkitSpeechRecognition' in window)) {
                alert("Chromeブラウザを使用してください。");
                return;
            }
            if (activeRecognition) {
                activeRecognition.stop();
                activeRecognition = null;
                if(btn) btn.classList.remove('listening');
                if (statusEl) statusEl.innerText = "待機中";
                return;
            }

            const recognition = new webkitSpeechRecognition();
            recognition.lang = 'ja-JP';
            recognition.interimResults = true;
            const isContinuous = (targetId === 'newLogContent');
            recognition.continuous = isContinuous;

            const inputEl = document.getElementById(targetId);
            let baseText = inputEl.value;

            if(btn) btn.classList.add('listening');
            if (statusEl) {
                statusEl.innerText = isContinuous ? "会話記録中..." : "聞き取り中...";
                statusEl.style.color = isContinuous ? "#ff0055" : "#00d4ff";
            }

            let finalTranscriptBuffer = baseText;
            if (finalTranscriptBuffer && !finalTranscriptBuffer.endsWith(' ')) finalTranscriptBuffer += ' ';

            recognition.onresult = (event) => {
                let interim = '';
                let newFinal = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) newFinal += event.results[i][0].transcript;
                    else interim += event.results[i][0].transcript;
                }
                if (newFinal) finalTranscriptBuffer += newFinal + (isContinuous ? "、" : "");
                inputEl.value = finalTranscriptBuffer + interim;
                inputEl.scrollTop = inputEl.scrollHeight;
            };

            recognition.onend = () => {
                if (activeRecognition === recognition) {
                    activeRecognition = null;
                    if(btn) btn.classList.remove('listening');
                    if (statusEl) {
                        statusEl.innerText = "待機中";
                        statusEl.style.color = "#aaa";
                    }
                }
            };
            activeRecognition = recognition;
            recognition.start();
        };

        // =======================================================
        // 3. モデル読み込み & カメラ設定 (既存機能)
        // =======================================================
        async function loadModels() {
            try {
                statusEl.innerText = "AIモデル読み込み中...";
                await faceapi.nets.tinyFaceDetector.loadFromUri('/js/models');
                await faceapi.nets.faceLandmark68Net.loadFromUri('/js/models');
                await faceapi.nets.faceRecognitionNet.loadFromUri('/js/models');

                if (typeof Hands === 'undefined') {
                    statusEl.innerText = "Handsモデルエラー";
                    return false;
                }
                hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@@mediapipe/hands/${file}`});
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(results => {
                    lastHandLandmarks = results.multiHandLandmarks && results.multiHandLandmarks.length > 0 
                        ? results.multiHandLandmarks[0] : null;
                });

                console.log("モデル読み込み完了");
                statusEl.innerText = "システム準備完了";
                return true;
            } catch (err) {
                console.error("Model Loading Error:", err);
                statusEl.innerText = "モデル読込エラー";
                return false;
            }
        }

        async function startVideo() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: { ideal: 1280 }, height: { ideal: 720 } } 
                });
                video.srcObject = stream;
            } catch (err) {
                console.error(err);
                statusEl.innerText = "カメラ起動エラー";
            }
        }

        function updateCanvasSize() {
            if (!video.videoWidth) return;
            const wRatio = window.innerWidth / window.innerHeight;
            const vRatio = video.videoWidth / video.videoHeight;
            let w, h;
            if (wRatio > vRatio) { h = window.innerHeight; w = h * vRatio; } 
            else { w = window.innerWidth; h = w / vRatio; }

            video.style.width = `${w}px`; video.style.height = `${h}px`;
            canvas.width = w; canvas.height = h;
            canvas.style.width = `${w}px`; canvas.style.height = `${h}px`;
            cursorCanvas.width = w; cursorCanvas.height = h;
            cursorCanvas.style.width = `${w}px`; cursorCanvas.style.height = `${h}px`;
            displaySize = { width: w, height: h };
            faceapi.matchDimensions(canvas, displaySize);
        }
        window.addEventListener('resize', updateCanvasSize);

        // =======================================================
        // 4. 指の幾何学計算 & ジェスチャー検知 (既存機能)
        // =======================================================
        function lerp(start, end, factor) { return start + (end - start) * factor; }
        function dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }

        function isCheckmarkGesture(landmarks) {
            if (!landmarks) return false;
            const wrist = landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const indexMCP = landmarks[5]; 
            const handScale = dist(wrist, indexMCP);
            if (handScale === 0) return false;

            const foldedFingers = [{ tip: 12, pip: 10 }, { tip: 16, pip: 14 }, { tip: 20, pip: 18 }];
            let areOthersFolded = true;
            for (let f of foldedFingers) {
                if (dist(landmarks[f.tip], wrist) > dist(landmarks[f.pip], wrist) * 1.1) {
                    areOthersFolded = false; break;
                }
            }
            if (!areOthersFolded) return false;
            if (dist(indexTip, wrist) < dist(indexMCP, wrist) * 1.5) return false; 
            return dist(thumbTip, indexTip) > handScale * 0.8;
        }

        function handleFingerInteraction(landmarks) {
            cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
            if (!landmarks) return;

            const indexTip = landmarks[8];
            const targetX = indexTip.x * cursorCanvas.width;
            const targetY = indexTip.y * cursorCanvas.height;

            if (cursorX === 0 && cursorY === 0) { cursorX = targetX; cursorY = targetY; } 
            else { cursorX = lerp(cursorX, targetX, SMOOTHING_FACTOR); cursorY = lerp(cursorY, targetY, SMOOTHING_FACTOR); }

            const thumbTip = landmarks[4];
            isPinching = (dist(indexTip, thumbTip) < 0.05);

            cursorCtx.beginPath();
            cursorCtx.arc(cursorX, cursorY, isPinching ? 10 : 6, 0, 2 * Math.PI);
            cursorCtx.fillStyle = isPinching ? '#ff0055' : '#00d4ff';
            cursorCtx.shadowBlur = 10; cursorCtx.shadowColor = cursorCtx.fillStyle;
            cursorCtx.fill();
            cursorCtx.shadowBlur = 0;
            cursorCtx.strokeStyle = 'white'; cursorCtx.lineWidth = 2; cursorCtx.stroke();

            const rect = cursorCanvas.getBoundingClientRect();
            const screenX = rect.left + cursorX;
            const screenY = rect.top + cursorY;
            const el = document.elementFromPoint(screenX, screenY);

            document.querySelectorAll('.hovered-by-finger').forEach(e => e.classList.remove('hovered-by-finger'));
            if (el && ['BUTTON', 'INPUT', 'TEXTAREA', 'A', 'DIV', 'SPAN'].includes(el.tagName)) {
                el.classList.add('hovered-by-finger');
                if (isPinching && !wasPinching) {
                    el.click();
                    el.focus();
                }
            }
            wasPinching = isPinching;
        }

        function showGestureFeedback(text) {
            const div = document.createElement('div');
            div.innerHTML = text; 
            Object.assign(div.style, {
                position: 'absolute', left: '50%', top: '40%',
                transform: 'translate(-50%, -50%)', fontSize: '4rem',
                color: '#00ff88', fontWeight: 'bold', textShadow: '0 0 20px #00ff88',
                zIndex: '2000', transition: 'opacity 1s ease-out, top 1s ease-out', pointerEvents: 'none'
            });
            document.body.appendChild(div);
            requestAnimationFrame(() => { div.style.opacity = '0'; div.style.top = '30%'; });
            setTimeout(() => div.remove(), 1000);
        }

        // =======================================================
        // 5. メインループ & 顔認識 (既存機能)
        // =======================================================
        async function detectionLoop() {
            if (!video || video.paused || video.ended) {
                requestAnimationFrame(detectionLoop);
                return;
            }

            if (hands) await hands.send({image: video});

            frameCount++;
            if (frameCount % 4 === 0 && !isProcessingFace) {
                isProcessingFace = true;
                faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
                    .withFaceLandmarks()
                    .withFaceDescriptors()
                    .then(detections => {
                        lastDetections = faceapi.resizeResults(detections, displaySize);
                        if (lastDetections.length === 1) {
                            const detection = lastDetections[0];
                            lastDetectedDescriptor = detection.descriptor;
                            fetch('/api/face/identify', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ Descriptor: JSON.stringify(Array.from(detection.descriptor)) })
                            }).then(r => r.json()).then(res => {
                                if (res.success) {
                                    detNameEl.innerText = res.name;
                                    detAffiliationEl.innerText = res.affiliation || "なし";
                                    updateLogView(res.logs);
                                    currentIdentifiedUserId = res.id;
                                    logInputArea.style.opacity = "1";
                                    logInputArea.style.pointerEvents = "auto";
                                } else {
                                    detNameEl.innerText = "未登録の対象";
                                    detAffiliationEl.innerText = "---";
                                    currentIdentifiedUserId = null;
                                    logInputArea.style.opacity = "0.5";
                                    logInputArea.style.pointerEvents = "none";
                                }
                            }).catch(() => {});
                        }
                        isProcessingFace = false;
                    }).catch(() => { isProcessingFace = false; });
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (lastDetections.length === 1) {
                drawTechBox(lastDetections[0].detection.box);
            }

            handleFingerInteraction(lastHandLandmarks);

            if (lastHandLandmarks) {
                if (isCheckmarkGesture(lastHandLandmarks)) {
                    if (!gestureCooldown) {
                        gestureCooldown = true;
                        setTimeout(() => { gestureCooldown = false; }, 1500);

                        const targetBtn = document.querySelector(`button[onclick*="'${lastFocusedInputId}'"]`);
                        
                        if (targetBtn) {
                            const willStart = !targetBtn.classList.contains('listening');
                            showGestureFeedback(willStart ? '🎙️ ON' : '🔇 OFF');
                            const isLogInput = (lastFocusedInputId === 'newLogContent');
                            
                            targetBtn.click(); // マイク切り替え

                            if (!willStart && isLogInput) {
                              showGestureFeedback("🚀 Auto Submit");
                              setTimeout(() => document.getElementById('addLogButton').click(), 1000); 
                            }
                        } else {
                            showGestureFeedback("⚠️ No Input");
                        }
                    }
                }
            }
            requestAnimationFrame(detectionLoop);
        }

        function drawTechBox(box) {
            const { x, y, width: w, height: h } = box;
            ctx.strokeStyle = '#00d4ff'; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
            const lineLen = 20;
            ctx.beginPath();
            ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 4;
            ctx.moveTo(x, y + lineLen); ctx.lineTo(x, y); ctx.lineTo(x + lineLen, y);
            ctx.moveTo(x + w - lineLen, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + lineLen);
            ctx.moveTo(x + w, y + h - lineLen); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - lineLen, y + h);
            ctx.moveTo(x + lineLen, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - lineLen);
            ctx.stroke();
        }

        function updateLogView(logs) {
            if (!logs || logs.length === 0) {
                logContainer.innerHTML = '<div style="text-align:center; color:#666; margin-top:20px;">履歴なし</div>';
                return;
            }
            let html = '';
            logs.forEach(l => {
                const date = new Date(l.date).toLocaleString();
                html += `<div class="log-item"><div class="log-date">${date}</div><div class="log-content">${l.content}</div></div>`;
            });
            logContainer.innerHTML = html;
        }

        // =======================================================
        // 6. Gemini連携 & 各種イベント (既存機能)
        // =======================================================
        async function summarizeWithGemini(text) {
            if (!GEMINI_API_KEY || GEMINI_API_KEY === "YOUR_NEW_API_KEY_HERE") {
                 alert("APIキーが設定されていません。"); return text; 
            }
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`;
            const systemPrompt = `あなたはPMです。以下の会話をビジネスライクに要約してください。\n【実施内容】【課題】【次回アクション】の3点。\n対象:${text}`;

            try {
                const response = await fetch(url, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ contents: [{ parts: [{ text: systemPrompt }] }] })
                });
                if (!response.ok) return text;
                const data = await response.json();
                return data.candidates?.[0].content.parts[0].text || text;
            } catch { return text; }
        }

        // 開始処理
        startVideo();
        video.addEventListener('loadedmetadata', () => { updateCanvasSize(); video.play(); });
        video.addEventListener('play', async () => {
            const loaded = await loadModels();
            if (loaded) requestAnimationFrame(detectionLoop);
        });

        // 登録ボタン
        document.getElementById('registerButton').addEventListener('click', async () => {
            if (!lastDetectedDescriptor) { alert("顔未検出"); return; }
            const data = {
                Name: document.getElementById('regName').value,
                Affiliation: document.getElementById('regAffiliation').value,
                Notes: document.getElementById('regNotes').value,
                FaceDescriptorJson: JSON.stringify(Array.from(lastDetectedDescriptor)) 
            };
            try {
                const res = await fetch('/api/face/register', {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                const result = await res.json();
                if(result.success) {
                    alert("登録完了");
                    document.getElementById('regName').value = "";
                    document.getElementById('regAffiliation').value = "";
                    document.getElementById('regNotes').value = "";
                } else { alert("エラー: " + result.message); }
            } catch(e) {}
        });

        // ログ追加ボタン
        document.getElementById('addLogButton').addEventListener('click', async () => {
            if (activeRecognition) { activeRecognition.stop(); }
            const originalContent = newLogInput.value;
            if (!currentIdentifiedUserId || !originalContent) { alert("対象認識または入力不足"); return; }

            const btn = document.getElementById('addLogButton');
            const originalBtnText = btn.innerText;
            btn.innerText = "AI処理中..."; btn.disabled = true;
            
            try {
                const summarizedText = await summarizeWithGemini(originalContent);
                await fetch('/api/face/add_log', {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ FaceId: currentIdentifiedUserId, Content: summarizedText })
                });
                const date = new Date().toLocaleString();
                logContainer.insertAdjacentHTML('afterbegin', 
                    `<div class="log-item" style="border-left:3px solid #ff0055;padding-left:5px;"><div class="log-date">${date}</div><div class="log-content">${summarizedText}</div></div>`);
                newLogInput.value = "";
            } catch { alert("保存失敗"); } 
            finally { btn.innerText = originalBtnText; btn.disabled = false; }
        });
    </script>
}